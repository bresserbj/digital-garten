{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Startingpoint","text":"<p>This page is deliberately kept in German, as I needed a place for myself and my notes, learning experiences, etc.</p> <p>Maybe I'll translate them at some point.</p>"},{"location":"#mein-kleiner-digitaler-garten","title":"Mein kleiner \"Digitaler Garten\"","text":"<p>Wissen hei\u00dft wissen, wo es geschrieben steht</p> <p>Albert Einstein - deutsch-amerikanischer Physiker</p> <p>Das ist das Motto, dass ich mehr oder weniger pflege - beruflich wie auch privat.</p> <p>Immer wieder \"erwische\" ich mich dabei, dass ich die gleichen Antworten, unabh\u00e4ngig vom beruflichen oder  privaten Umfeld, im Internet nachschlage, anwende und vergesse. Dies f\u00fchrt dazu, dass ich zu einem sp\u00e4teren Zeitpunkt wieder genau die gleiche Zeile in die Suchmaschine meiner Wahl tippe und hoffe, DIE Antwort wieder zu finden, die beim letzten Mal so gut funktionierte.</p> <p>Das ein oder andere Mal versagte dies bereits und deswegen \u00fcberlegte ich, wie dies zu \u00e4ndern sein.</p> <p>Entsprechend ist diese Seite entstanden, die wissen f\u00fcr mich festh\u00e4lt, die ich stetig erweitern sowie konsultieren kann.</p>"},{"location":"architecture/goal/","title":"Software Architecture","text":""},{"location":"architecture/goal/#ziele-einer-softwarearchitektur","title":"Ziele einer Softwarearchitektur","text":"<p>Das Ziel einer Softwarearchitektur ist die Aufteilung eines Systems in Komponenten sowie die Anordung und Eigenschaften dieser Komponenten nd wie diese miteinander kommunizieren.</p> <p>Hierbei sollte eine gute Architektur laut Robert C. Martin die Eigenschaft erfuellen waehrend  ihrer Lebenszeit mit moeglichst geringem und gleichbleibendem Aufwand veraenderbar zu sein.</p>"},{"location":"architecture/hexagonal_architecture/","title":"Hexagonal Architecture","text":""},{"location":"architecture/hexagonal_architecture/#was-ist-eine-hexagonale-architektur","title":"Was ist eine Hexagonale Architektur?","text":"<p>Eine Hexagonale Architektur, oder auch \"Ports und Adapter\" genannt, zeichnet sich laut des Autors Alistair Cockburn durch nachfolgende drei Ziele aus:</p> <ol> <li>Es soll keinen Unterschied machen ob die Businesslogik von einer UI, einer API oder einem Test-Framework aufgerufen wird.</li> <li>Die Businesslogik soll isoliert von der Datenbank und sonstiger Infrastruktur oder Drittsystemene entwickelt und    getestet werden koennen. </li> <li>Aenderungen an externen Schnittstellen oder Modernisierungen der Infrastruktur sollen ohne Anpassungen an der     Businesslogik moeglich sein.</li> </ol>"},{"location":"architecture/hexagonal_architecture/#ports-und-adapter","title":"Ports und Adapter","text":"<p>Erreicht werden diese drei Ziele durch die Isolation der Businesslogik ueber sogenannte \"Ports\" und \"Adapter\".</p> <p>Die Businesslogik liegt im Kern der Anwendung und definiert \"Ports\" um von ausserhalb gesteuert zu werden und um zu steuern. Wichtig ist es, dass es der Businesslogik irrelevant ist, welche technischen Details sich hinter den Ports befinden. Alle Komponenten ausserhalb des Kerns sind gegen die Ports zu implementieren.</p> <p>Die Anbindung der externen Komponente erfolgt durch \"Adapter\".</p> <p>Applikation \u2192 Port \u2192 Database Adapter \u2192 Database</p> <p>An einem Port koennen mehrere Adapter angeschlossen werden. So kann zB. an einen Port zur Steuerung einer Anwendung  ein Adapter fuer die UI und ein Adapter fuer eine API angeschlossen sein.</p>"},{"location":"architecture/hexagonal_architecture/#steuernde-und-gesteuerte-ports","title":"Steuernde und gesteuerte Ports","text":"<p>Es gibt zwei Arten von Ports nd Adaptern - steuernde und gesteuerte. Steuernde Ports und Adapter werden auch als \"driving\" oder \"primary\" bezeichnet. Gesteuerte Ports werden als \"driven\" oder \"secondary\" bezeichnet.</p>"},{"location":"architecture/hexagonal_architecture/#dependency-rule","title":"Dependency Rule","text":"<p>Um die technischen Details und Anbindungen zur Anwendung abzutrennen koenne nwir die sogenannte \"Dependency Rule\" nutzen. Diese besagt, dass Abhaengigkeiten ausschliesslich von aussen nach innen, also in Richtung der Anwendung zeigen duerfen.</p> <p>Adapter: <pre><code>package com.bank.transfer.infrastructure.adapter.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\nclass TransferController(\n   private val transferMoneyPort: TransferMoney\n) {\n\n   fun transfer(amount: BigDecimal, from: UUID, to: UUID): TransferMoneyRespone {\n      return transferMoneyPort.transfer(TransferMoneyRequest(amount, from, to))\n   }\n}\n</code></pre> Port: <pre><code>package com.bank.transfer.app.port.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\ninterface TransferMoney {\n   fun transfer(request: TransferMoneyRequest): TransferMoneyRespone\n}\n\ndata class TransferMoneyRequest(\n   val amount: BigDecimal,\n   val from: UUID,\n   val to: UUID\n)\n\nsealed class TransferMoneyResponse {\n   object Success : TransferMoneyResponse()\n   object InvalidAmount : TransferMoneyResponse()\n}\n</code></pre></p> <p>Service: <pre><code>package com.bank.transfers.app.service\n\nclass TransferService : TransferMoney {\n   override fun transfer(request: TransferMoneyRequest): TransferMoneyRespone {\n      TODO(\"Not yet implemented\")\n   }\n\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dependency-inversion","title":"Dependency Inversion","text":"<p>Auch hier wird der Port durch ein Interface definiert. Allerdings sind die Beziehungen zwischen den Klassen vertauscht. Der Adapter benutzt den Port nicht, sondern implementiert diesen und der Service implementiert den Port nicht sondern benutzt ihn.</p> <p>Port: <pre><code>package com.bank.transfers.app.port.driven\n\ninterface AccountFinder {\n    fun find(customerId: CustomerId): Account?\n}\n</code></pre></p> <p>Adapter <pre><code>package com.bank.transfers.infrastructure.adapter.driven\n\nclass InMemoryAccounts : AccountFinder {\n    private val accounts = mutableMapOf&lt;CustomerId, Account&gt;()\n\n   override fun find(customerId: CustomerId): Account? = accounts.get(customerId)\n}\n</code></pre></p> <p>Services: <pre><code>package com.bank.transfers.app.service\n\nclass AccountService(private val accountFinder: AccountFinder) {\n   override fun find(customerId: CustomerId) {\n      TODO(\"Not yet implemented\")\n   }\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dilemma-der-isolation","title":"Dilemma der Isolation","text":"<p>Die Isolierung der technischen Details fuehrt dazu, dass bei der Verwendung von ORM ein Dilemma darin besteht, dass der  Kern der Anwendung die Details des Persistierenden Adapters nicht kennen soll, also die Entitaet. </p> <p>Hier gibt es einen Loesungsansatz indem man zum einen die Klasse der Entitaet im Adapter hat, die keine Businesslogik beinhaltet, aber dafuer die technischen Annotationen fuer die Persistierung, und zum Anderen dem Kern der Anwendung eine eigene Modelklasse implementiert.</p> <p>Das gleiche Dilemma finden wir auch in API-Adaptern, die oft nicht alle Attribute einer Entitaet sichtbar machen sollen.</p>"},{"location":"architecture/hexagonal_architecture/#vorteile-der-hexagonalen-architektur","title":"Vorteile der Hexagonalen Architektur","text":"<ul> <li>Aenderbarkeit - Die Businesslogik kann geaendert werden ohne die Adapter oder Infrastruktur aendern zu muessen und umgekehrt.</li> <li>Isolierung - Der Kern der Anwendung umfasst nur fachliche Themen und technische Themen sind in den Adaptern implementiert.</li> <li>Entwicklung - Entwicklung an Komponenten kann aufgeteilt werden.</li> <li>Testbarkeit - Komponenten koennen vollstaendig isoliert geteste werden.</li> </ul>"},{"location":"architecture/hexagonal_architecture/#nachteile-der-hexagonalen-architektur","title":"Nachteile der Hexagonalen Architektur","text":"<ul> <li>Erheblicher Mehraufwand der sich fur CRUD-Microservices eher nicht lohnt.</li> </ul>"},{"location":"architecture/principles/dry/","title":"DRY","text":"<p>DRY steht f\u00fcr \"Don't Repeat Yourself\". </p> <p>Bedeutet, dass man wiederholende Logik, Code und Muster zugunsten modularer referenzierbarem Codes reduzieren sollte</p>"},{"location":"architecture/principles/dry/#warum-dry","title":"Warum DRY?","text":"<p>DRY hilft dabei lesbareren und wartbareren Code zu produzieren.</p>"},{"location":"architecture/principles/dry/#wann-ist-es-dry-genug","title":"Wann ist es \"DRY\" genug?","text":"<p>Als Faustregel kann man hier die \"Regel der Drei\" (eng. Rule of Three) nutzen. Diese besagt, dass beim dritten Mal, wenn man auf ein bestimmtes Muster st\u00f6\u00dft, dieses wahrscheinlich wiederverwendbar abstrahiert werden sollte.</p>"},{"location":"architecture/principles/dry/#zusammenfassung","title":"Zusammenfassung","text":"<p>DRY ist ein Prinzip das immer angestrebt werden sollte.  Es spart Aufwand, erh\u00f6ht die Lesbarkeit, Wartbarkeit und Qualit\u00e4t des Quellcode. </p>"},{"location":"architecture/principles/dry/#referenzen","title":"Referenzen","text":"<ul> <li>getDbt - Dry</li> </ul>"},{"location":"architecture/principles/principles/","title":"Prinzipien","text":""},{"location":"architecture/principles/principles/#muster-patterns","title":"Muster / Patterns","text":"<p>Muster/Pattern werden immer dann verwendet, wenn man in einem ganz konkreten Szenario ein Problem hat, dass zu einem fixen Zeitpunkt, an einer definierten Stelle gel\u00f6st werden soll.</p>"},{"location":"architecture/principles/principles/#beispiele","title":"Beispiele","text":"<ol> <li>Ein Austausch eines Algorithmus zur Projektlaufzeit an einer definierten Stelle im Code -&gt; Strategy Design Pattern</li> <li>Ausf\u00fchrung einer hochskalierbaren einzelnen Funktion innerhalb der Clode -&gt; Serverless Architecture Pattern</li> </ol>"},{"location":"architecture/principles/principles/#prinzipien","title":"Prinzipien","text":"<p>Prinzipien sind wie Muster/Patterns, es hilft bei der L\u00f6sung von Probleme. Dies geschieht allerdings nicht wie bei  dem Mustern/pattern zu einem fixen Zeitpunkt an einer definierten Stelle, sondern geschieht kontinuierlich \u00fcber einen l\u00e4ngeren Zeitraum auf verschiebene Ebenen.</p>"},{"location":"architecture/principles/principles/#beispiel","title":"Beispiel","text":"<ol> <li>Es soll vermieden werden doppelten Quellcode zu erzeugen -&gt; DRY-Prinzip</li> </ol>"},{"location":"architecture/principles/principles/#zusammenfassung","title":"Zusammenfassung","text":"<p>Ein Prinzip ist eine Regel bzw. ein Gesetz, das in der Entwicklung zu jedem Zeitpunkt einzuhalten ist und welches der Software bestimmte Eigenschaften hinzuf\u00fcgt.</p> <p>Ein Prinzip addressiert hierbei ein Qualit\u00e4tsmerkmal der Software wie z.B. die Lesbarkeit von Quellcode, Erweiterbarkeit von Anwendungen, Wartbarkeit etc.</p> <p>Prinzipien k\u00f6nnen untereinander konkurrieren.</p>"},{"location":"architecture/principles/solid/","title":"SOLID","text":""},{"location":"architecture/principles/solid/#solid","title":"SOLID","text":"<p>Alle Prinzipien von SOLID sind \"Entwurfsprinzipien\"</p> <p>Qualit\u00e4tsmerkamel von SOLID: * Einfacher Analysierbar / Lesbar * Flexibel * Wartbar</p> <p>Ein Entwurfsprinzip ist ein Prinzip, dass immer und st\u00e4ndig bei einem Entwurf von Designs / Architektur ber\u00fccksichtigt werden soll.</p>"},{"location":"architecture/principles/solid/#single-responsibility-priciples-srp","title":"Single Responsibility Priciples (SRP)","text":"<ul> <li>Ein beliebiges System (Methode, Klasse, Schicht) hat nur eine einzige Verantwortung/Aufgabe</li> <li>Vorteile: kurz, knapp, \u00fcbersichtlich, wenig komplex -&gt; einfach wartbar, lesbar</li> </ul> <p>Hilft durch das \"richtige\" schneiden von Bestandteilen der Software diese besser analysierbar, erweiterbar und damit austauschbar zu machen.</p>"},{"location":"architecture/principles/solid/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<ul> <li>Offen f\u00fcr Erweiterungen</li> <li>Geschlossen f\u00fcr Ver\u00e4nderungen</li> <li>Es werden Erweiterungspunkte geschaffen, sodass Quellcode nicht gro\u00df ge\u00e4ndert werden muss.</li> </ul> <p>Sorgt daf\u00fcr, dass die Anwendung erweiterbarer, modifizierbarer und so flexibler an die Projektsituation angepasst werden kann</p>"},{"location":"architecture/principles/solid/#liskov-subtitution-priciple-lsp","title":"Liskov Subtitution Priciple (LSP)","text":"<ul> <li>Definiert einen Implementierungs-Kontrakt</li> <li>Subklassen m\u00fcssen an die Stelle der Basisklasse treten k\u00f6nnen</li> </ul> <p>Stellt sicher, dass hinter einem kontrakt eine beliebige Implementierung genutzt werden kann, ohne dass der Aufrufer dies bemerkt.</p>"},{"location":"architecture/principles/solid/#interface-segregation-pricinple-isp","title":"Interface Segregation Pricinple (ISP)","text":"<ul> <li>Regelt die Granularit\u00e4t der Kontrakte</li> <li>Kontrakte immer f\u00fcr einzelne Konsumenten optimieren</li> </ul>"},{"location":"architecture/principles/solid/#dependency-inversion-pricinple-dip","title":"Dependency Inversion Pricinple (DIP)","text":"<ul> <li>Abh\u00e4ngigkeiten belasten alle relevanten Qualit\u00e4tsattribute</li> </ul> <p>Sorgt daf\u00fcr, dass in einer Anwendung keine Abh\u00e4ngigkeiten gegen Implementierung bestehen, sondern nur gegen Kontrakte</p>"},{"location":"coding/rule_of_three/","title":"Regel der Drei","text":"<p>Die \"Regel der Drei\" (eng. Rule of Three) is eine Faustregel in der Softwareentwicklung,  die besagt, dass wenn ein bestimmtes Muster oder eine bestimmte Struktur im Code zum dritten mal wiederkehrt, es an der Zeit ist, diese in eine abstrakte und wiederverwendbare Einheit zu extrahieren.</p> <p>Dies erh\u00f6ht die Wartbarkeit und Lesbarkeit des Codes. </p> <p>Somit wird Redundanz im Code vermieden und die Effizienz und Klarheit dieses gef\u00f6rdert.</p>"},{"location":"coding/rule_of_three/#quellen","title":"Quellen:","text":"<ul> <li>Wikipedia - Rule of three(computer programming)</li> <li>Western Oregon University - CS-161 Computer Science 1</li> </ul>"},{"location":"coding/tdd/","title":"TDD","text":"<p>dw--- title: Test driven Development date: 20240409 author: bresserbj</p>"},{"location":"coding/macOs/environment/","title":"Environment","text":"<p>Diese Seite soll mir dabei helfen, Anforderungen an mein Macbook zu definieren und als Art Anleitung zum neuaufsetzen eines Macbooks.</p>"},{"location":"coding/macOs/environment/#anforderungen-an-mein-macbook","title":"Anforderungen an mein Macbook","text":"<ul> <li>Softwareentwicklung mit folgenden Frameworks, Technologien und Software<ul> <li>Kotlin</li> <li>Java</li> <li>Docker</li> <li>Gradle</li> <li>Python</li> <li>Git</li> <li>IntelliJ</li> </ul> </li> </ul>"},{"location":"coding/macOs/environment/#alfred","title":"Alfred","text":"<p>Alfred bietet eine effizientere Erweiterung fuer MacOs als die Spotlight-Suche vom Os selbst. Daher sollte die AlfredApp installiert werden: https://www.alfredapp.com/</p>"},{"location":"coding/macOs/environment/#brew","title":"Brew","text":"<p>Brew ist relativ einfach installiert. Man oeffnet das Terminal und gibt folgende Zeile ein</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Nachfolgend sind die weiteren Installationen relativ schnell erledigt.</p>"},{"location":"coding/macOs/environment/#softwareinstallationen-mit-brew","title":"Softwareinstallationen mit Brew","text":"<pre><code># GIT\nbrew install git\n\n# Docker\nbrew install docker\n</code></pre>"},{"location":"coding/macOs/environment/#terminal","title":"Terminal","text":"<p>Als Terminal faellt die Wahl auf iTerm2 mit einigen Modifikationen.</p> <pre><code>brew cask install iterm2\n</code></pre>"},{"location":"coding/macOs/environment/#zsh-oh-my-zsh","title":"zsh &amp; \"oh-my-zsh\"","text":"<p>Um zsh zu installieren nutzten wir im Terminal: </p> <pre><code>brew install zsh\n</code></pre> <p>Fuer eine Installation von oh-my-zsh nutzen wir nachfolgenden Befehl, wodurch das Standardterminal  anschliessend automatisch durch zsh ersetzt wird. </p> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"coding/macOs/environment/#install-fuck","title":"Install 'Fuck'","text":"<p>Eins der besten Plugins fuer Faule und Menschen die gerne Tippfehler in der Konsole begehen.ds</p> <pre><code>brew install thefuck\n</code></pre>"},{"location":"coding/macOs/environment/#wichtige-anpassungen","title":"Wichtige Anpassungen","text":"<p>Die zsh_fallout.json zu den Profilen hinzufuegen.</p>"},{"location":"coding/macOs/environment/#theme","title":"Theme","text":"<p>Zuerst muessen wir das Theme konfigurieren. Hierzu benoetigen wie einige Fonts etc.</p> <pre><code>sudo apt install fonts-powerline\n\ngit clone https://github.com/abertsch/Menlo-for-Powerline.git\ncd Menlo-for-Powerline\ncp \"Menlo for Powerline.ttf\" ~/.fonts\n</code></pre> <pre><code>vi ~/.zshrc\n\n# Set name of the theme to load --- if set to \"random\", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME=\"agnoster\"\n</code></pre>"},{"location":"coding/macOs/environment/#plugins","title":"Plugins","text":"<p>Um externe Plugins zu installieren kann dieser Befehl genutzt werden <pre><code>git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions\n</code></pre></p> <pre><code>vi ~/.zshrc\n\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(\n  git\n  github\n  brew\n  docker\n  npm\n  macos\n  bgnotify\n  zsh-syntax-highlighting\n  zsh-autosuggestions\n  web-search\n)\n</code></pre>"},{"location":"coding/macOs/environment/#alias-parameter","title":"Alias Parameter","text":"<pre><code>vi ~/.zshrc\n\n# Example aliases\n# alias zshconfig=\"mate ~/.zshrc\"\n# alias ohmyzsh=\"mate ~/.oh-my-zsh\"\n\nalias zshconfig=\"nano ~/.zshrc\"\nalias ohmyzsh=\"nano ~/.oh-my-zsh\"\nalias gpf='git push -f'\n\n# Docker alias\nalias dkps=\"docker ps\"\nalias dkst=\"docker stats\"\nalias dkpsa=\"docker ps -a\"\nalias dkimgs=\"docker images\"\nalias dkcpup=\"docker-compose up -d\"\nalias dkcpdown=\"docker-compose down\"\nalias dkcpstart=\"docker-compose start\"\nalias dkcpstop=\"docker-compose stop\"\n\n# Kubectl alias\nalias kdev='kubectl -n dev'\nalias kpg='kubectl -n playground'\nalias ktest='kubectl -n test'\nalias kprod='kubectl -n prod'\nalias kpreprod='kubectl -n preprod'\nalias vpnstart='~/Scripts/vpn-start.sh'\nalias vpn-start='~/Scripts/vpn-start.sh'\n\neval $(thefuck --alias)\n</code></pre>"},{"location":"coding/macOs/environment/#macbook-shortcuts","title":"Macbook shortcuts","text":"<p>TBD</p>"}]}