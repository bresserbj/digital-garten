{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Startingpoint","text":"<p>This page is deliberately kept in German, as I needed a place for myself and my notes, learning experiences, etc.</p> <p>Maybe I'll translate them at some point.</p>"},{"location":"#mein-kleiner-digitaler-garten","title":"Mein kleiner \"Digitaler Garten\"","text":"<p>Wissen hei\u00dft wissen, wo es geschrieben steht</p> <p>Albert Einstein - deutsch-amerikanischer Physiker</p> <p>Das ist das Motto, dass ich mehr oder weniger pflege - beruflich wie auch privat.</p> <p>Immer wieder \"erwische\" ich mich dabei, dass ich die gleichen Antworten, unabh\u00e4ngig vom beruflichen oder  privaten Umfeld, im Internet nachschlage, anwende und vergesse. Dies f\u00fchrt dazu, dass ich zu einem sp\u00e4teren Zeitpunkt wieder genau die gleiche Zeile in die Suchmaschine meiner Wahl tippe und hoffe, DIE Antwort wieder zu finden, die beim letzten Mal so gut funktionierte.</p> <p>Das ein oder andere Mal versagte dies bereits und deswegen \u00fcberlegte ich, wie dies zu \u00e4ndern sein.</p> <p>Entsprechend ist diese Seite entstanden, die wissen f\u00fcr mich festh\u00e4lt, die ich stetig erweitern sowie konsultieren kann.</p>"},{"location":"architecture/domain_driven_design/","title":"Domain Driven Design","text":""},{"location":"architecture/domain_driven_design/#domain-driven-design","title":"Domain Driven Design","text":"<p>Domain Driven Design (DDD) kann man grob in zwei Segmente von Tools unterteilen: strategisch und taktisch. Sowohl die strategischen als auch taktischen Muster und Praktiken von DDD richten die Softwarearchitektur auf  das Geschaeftsmodell (Business) aus.</p> <p>Strategische Aspekte von DDD beantworten die Fragen des \"Was?\" und \"Wieso?\", waehrend die taktischen Aspekte das \"Wie?\" beschreiben.</p>"},{"location":"architecture/domain_driven_design/#strategisch","title":"Strategisch","text":"<p>Die strategischen Tools von DDD werden benutzt um die Business Domains und Strategie des Unternehmens zu identifizieren. Auf Basis des Wissens der Business Domains kann anschliessend eine \"high level\" design Entscheidung getroffen werden, wie man die Systeme in einzelne Komponenten zerlegt und daraufhin Integrationsmuster definiert.</p>"},{"location":"architecture/domain_driven_design/#taktisch","title":"Taktisch","text":"<p>Die taktischen Werkzeuge von DDD befassen sich mit einem anderen Aspekt der Probleme. Mit diesen Mustern kann Code auf  eine Art und Weise geschrieben werden, der die Anwendungsdomaine widerspiegelt, ihre Ziele anspricht und die Sprache des Unternehmens spricht.</p>"},{"location":"architecture/domain_driven_design/#strategisch-analyze-von-business-domains","title":"Strategisch: Analyze von Business Domains","text":"<p>Um eine effiziente Loesung du entwickeln muss man zuerst das Problem verstanden haben. In diesem Fall ist das Problem die Software, die es zu bauen gilt.</p> <p>Unternehmen arbeiten in Geschaeftsfeldern (Business Domain).  Ein Gesch\u00e4ftsfeld (Business Domain) definiert den Hauptt\u00e4tigkeitsbereich eines Unternehmens. Es ist die Dienstleistung, die das Unternehmen f\u00fcr seine Kunden erbringt.</p> <p>Um die Ziele seines Geschaefsfelds zu erfuellen ist es fuer Unternehmen notwendig seine Aktivitaeten in Subdomains aufzuteilen. Alle Subdomains gemeinsam formen die Business Domain.</p>"},{"location":"architecture/domain_driven_design/#subdomains","title":"Subdomains","text":"<p>Eine Subdomain wird in drei Typen unterteilt: Core, Generic und Supporting Subdomains sind hierbei wie Karten eines Kartenhauses zu sehen: Nimmt man eine Karte weg faellt die Struktur in sich zusammen.</p> <ul> <li>Core Subdomains spiegeln den kompetativen Vorteil des Unternehmens in seiner Branche wieder.</li> <li>Generic Subdomains, bieten keinen kompetativen Vorteil und koennen auch von anderen Unternehmen so genutzt werden.</li> <li>Supporting Subdomains bieten keinen kompetativen Vorteil, haben aber eine niedrige Einstiegshuerde.</li> </ul> <p>Um zwischen diesen Typen unterscheiden zu koennen macht es Sinn die nachfolgende Tabelle zu beruecksichtigen:</p> Subdomain type Competitive advantage Complexity Volatility Implementation Problem Core Yes High High Inhouse Interesting Generic No High Low Buy Solved Supporting No Low Low Inhouse/Outsource Obvious"},{"location":"architecture/domain_driven_design/#strategisch-domain-knowledge","title":"Strategisch: Domain Knowledge","text":""},{"location":"architecture/goal/","title":"Software Architecture","text":""},{"location":"architecture/goal/#ziele-einer-softwarearchitektur","title":"Ziele einer Softwarearchitektur","text":"<p>Das Ziel einer Softwarearchitektur ist die Aufteilung eines Systems in Komponenten sowie die Anordung und Eigenschaften dieser Komponenten nd wie diese miteinander kommunizieren.</p> <p>Hierbei sollte eine gute Architektur laut Robert C. Martin die Eigenschaft erfuellen waehrend  ihrer Lebenszeit mit moeglichst geringem und gleichbleibendem Aufwand veraenderbar zu sein.</p>"},{"location":"architecture/hexagonal_architecture/","title":"Hexagonal Architecture","text":""},{"location":"architecture/hexagonal_architecture/#was-ist-eine-hexagonale-architektur","title":"Was ist eine Hexagonale Architektur?","text":"<p>Eine Hexagonale Architektur, oder auch \"Ports und Adapter\" genannt, zeichnet sich laut des Autors Alistair Cockburn durch nachfolgende drei Ziele aus:</p> <ol> <li>Es soll keinen Unterschied machen ob die Businesslogik von einer UI, einer API oder einem Test-Framework aufgerufen wird.</li> <li>Die Businesslogik soll isoliert von der Datenbank und sonstiger Infrastruktur oder Drittsystemene entwickelt und    getestet werden koennen. </li> <li>Aenderungen an externen Schnittstellen oder Modernisierungen der Infrastruktur sollen ohne Anpassungen an der     Businesslogik moeglich sein.</li> </ol>"},{"location":"architecture/hexagonal_architecture/#ports-und-adapter","title":"Ports und Adapter","text":"<p>Erreicht werden diese drei Ziele durch die Isolation der Businesslogik ueber sogenannte \"Ports\" und \"Adapter\".</p> <p>Die Businesslogik liegt im Kern der Anwendung und definiert \"Ports\" um von ausserhalb gesteuert zu werden und um zu steuern. Wichtig ist es, dass es der Businesslogik irrelevant ist, welche technischen Details sich hinter den Ports befinden. Alle Komponenten ausserhalb des Kerns sind gegen die Ports zu implementieren.</p> <p>Die Anbindung der externen Komponente erfolgt durch \"Adapter\".</p> <p>Applikation \u2192 Port \u2192 Database Adapter \u2192 Database</p> <p>An einem Port koennen mehrere Adapter angeschlossen werden. So kann zB. an einen Port zur Steuerung einer Anwendung  ein Adapter fuer die UI und ein Adapter fuer eine API angeschlossen sein.</p>"},{"location":"architecture/hexagonal_architecture/#steuernde-und-gesteuerte-ports","title":"Steuernde und gesteuerte Ports","text":"<p>Es gibt zwei Arten von Ports nd Adaptern - steuernde und gesteuerte. Steuernde Ports und Adapter werden auch als \"driving\" oder \"primary\" bezeichnet. Gesteuerte Ports werden als \"driven\" oder \"secondary\" bezeichnet.</p>"},{"location":"architecture/hexagonal_architecture/#dependency-rule","title":"Dependency Rule","text":"<p>Um die technischen Details und Anbindungen zur Anwendung abzutrennen koenne nwir die sogenannte \"Dependency Rule\" nutzen. Diese besagt, dass Abhaengigkeiten ausschliesslich von aussen nach innen, also in Richtung der Anwendung zeigen duerfen.</p> <p>Adapter: <pre><code>package com.bank.transfer.infrastructure.adapter.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\nclass TransferController(\n   private val transferMoneyPort: TransferMoney\n) {\n\n   fun transfer(amount: BigDecimal, from: UUID, to: UUID): TransferMoneyRespone {\n      return transferMoneyPort.transfer(TransferMoneyRequest(amount, from, to))\n   }\n}\n</code></pre> Port: <pre><code>package com.bank.transfer.app.port.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\ninterface TransferMoney {\n   fun transfer(request: TransferMoneyRequest): TransferMoneyRespone\n}\n\ndata class TransferMoneyRequest(\n   val amount: BigDecimal,\n   val from: UUID,\n   val to: UUID\n)\n\nsealed class TransferMoneyResponse {\n   object Success : TransferMoneyResponse()\n   object InvalidAmount : TransferMoneyResponse()\n}\n</code></pre></p> <p>Service: <pre><code>package com.bank.transfers.app.service\n\nclass TransferService : TransferMoney {\n   override fun transfer(request: TransferMoneyRequest): TransferMoneyRespone {\n      TODO(\"Not yet implemented\")\n   }\n\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dependency-inversion","title":"Dependency Inversion","text":"<p>Auch hier wird der Port durch ein Interface definiert. Allerdings sind die Beziehungen zwischen den Klassen vertauscht. Der Adapter benutzt den Port nicht, sondern implementiert diesen und der Service implementiert den Port nicht sondern benutzt ihn.</p> <p>Port: <pre><code>package com.bank.transfers.app.port.driven\n\ninterface AccountFinder {\n    fun find(customerId: CustomerId): Account?\n}\n</code></pre></p> <p>Adapter <pre><code>package com.bank.transfers.infrastructure.adapter.driven\n\nclass InMemoryAccounts : AccountFinder {\n    private val accounts = mutableMapOf&lt;CustomerId, Account&gt;()\n\n   override fun find(customerId: CustomerId): Account? = accounts.get(customerId)\n}\n</code></pre></p> <p>Services: <pre><code>package com.bank.transfers.app.service\n\nclass AccountService(private val accountFinder: AccountFinder) {\n   override fun find(customerId: CustomerId) {\n      TODO(\"Not yet implemented\")\n   }\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dilemma-der-isolation","title":"Dilemma der Isolation","text":"<p>Die Isolierung der technischen Details fuehrt dazu, dass bei der Verwendung von ORM ein Dilemma darin besteht, dass der  Kern der Anwendung die Details des Persistierenden Adapters nicht kennen soll, also die Entitaet. </p> <p>Hier gibt es einen Loesungsansatz indem man zum einen die Klasse der Entitaet im Adapter hat, die keine Businesslogik beinhaltet, aber dafuer die technischen Annotationen fuer die Persistierung, und zum Anderen dem Kern der Anwendung eine eigene Modelklasse implementiert.</p> <p>Das gleiche Dilemma finden wir auch in API-Adaptern, die oft nicht alle Attribute einer Entitaet sichtbar machen sollen.</p>"},{"location":"architecture/hexagonal_architecture/#vorteile-der-hexagonalen-architektur","title":"Vorteile der Hexagonalen Architektur","text":"<ul> <li>Aenderbarkeit - Die Businesslogik kann geaendert werden ohne die Adapter oder Infrastruktur aendern zu muessen und umgekehrt.</li> <li>Isolierung - Der Kern der Anwendung umfasst nur fachliche Themen und technische Themen sind in den Adaptern implementiert.</li> <li>Entwicklung - Entwicklung an Komponenten kann aufgeteilt werden.</li> <li>Testbarkeit - Komponenten koennen vollstaendig isoliert geteste werden.</li> </ul>"},{"location":"architecture/hexagonal_architecture/#nachteile-der-hexagonalen-architektur","title":"Nachteile der Hexagonalen Architektur","text":"<ul> <li>Erheblicher Mehraufwand der sich fur CRUD-Microservices eher nicht lohnt.</li> </ul>"},{"location":"architecture/principles/dry/","title":"DRY","text":"<p>DRY steht f\u00fcr \"Don't Repeat Yourself\". </p> <p>Bedeutet, dass man wiederholende Logik, Code und Muster zugunsten modularer referenzierbarem Codes reduzieren sollte</p>"},{"location":"architecture/principles/dry/#warum-dry","title":"Warum DRY?","text":"<p>DRY hilft dabei lesbareren und wartbareren Code zu produzieren.</p>"},{"location":"architecture/principles/dry/#wann-ist-es-dry-genug","title":"Wann ist es \"DRY\" genug?","text":"<p>Als Faustregel kann man hier die \"Regel der Drei\" (eng. Rule of Three) nutzen. Diese besagt, dass beim dritten Mal, wenn man auf ein bestimmtes Muster st\u00f6\u00dft, dieses wahrscheinlich wiederverwendbar abstrahiert werden sollte.</p>"},{"location":"architecture/principles/dry/#zusammenfassung","title":"Zusammenfassung","text":"<p>DRY ist ein Prinzip das immer angestrebt werden sollte.  Es spart Aufwand, erh\u00f6ht die Lesbarkeit, Wartbarkeit und Qualit\u00e4t des Quellcode. </p>"},{"location":"architecture/principles/dry/#referenzen","title":"Referenzen","text":"<ul> <li>getDbt - Dry</li> </ul>"},{"location":"architecture/principles/principles/","title":"Prinzipien","text":""},{"location":"architecture/principles/principles/#muster-patterns","title":"Muster / Patterns","text":"<p>Muster/Pattern werden immer dann verwendet, wenn man in einem ganz konkreten Szenario ein Problem hat, dass zu einem fixen Zeitpunkt, an einer definierten Stelle gel\u00f6st werden soll.</p>"},{"location":"architecture/principles/principles/#beispiele","title":"Beispiele","text":"<ol> <li>Ein Austausch eines Algorithmus zur Projektlaufzeit an einer definierten Stelle im Code -&gt; Strategy Design Pattern</li> <li>Ausf\u00fchrung einer hochskalierbaren einzelnen Funktion innerhalb der Clode -&gt; Serverless Architecture Pattern</li> </ol>"},{"location":"architecture/principles/principles/#prinzipien","title":"Prinzipien","text":"<p>Prinzipien sind wie Muster/Patterns, es hilft bei der L\u00f6sung von Probleme. Dies geschieht allerdings nicht wie bei  dem Mustern/pattern zu einem fixen Zeitpunkt an einer definierten Stelle, sondern geschieht kontinuierlich \u00fcber einen l\u00e4ngeren Zeitraum auf verschiebene Ebenen.</p>"},{"location":"architecture/principles/principles/#beispiel","title":"Beispiel","text":"<ol> <li>Es soll vermieden werden doppelten Quellcode zu erzeugen -&gt; DRY-Prinzip</li> </ol>"},{"location":"architecture/principles/principles/#zusammenfassung","title":"Zusammenfassung","text":"<p>Ein Prinzip ist eine Regel bzw. ein Gesetz, das in der Entwicklung zu jedem Zeitpunkt einzuhalten ist und welches der Software bestimmte Eigenschaften hinzuf\u00fcgt.</p> <p>Ein Prinzip addressiert hierbei ein Qualit\u00e4tsmerkmal der Software wie z.B. die Lesbarkeit von Quellcode, Erweiterbarkeit von Anwendungen, Wartbarkeit etc.</p> <p>Prinzipien k\u00f6nnen untereinander konkurrieren.</p>"},{"location":"architecture/principles/solid/","title":"SOLID","text":""},{"location":"architecture/principles/solid/#solid","title":"SOLID","text":"<p>Alle Prinzipien von SOLID sind \"Entwurfsprinzipien\"</p> <p>Qualit\u00e4tsmerkamel von SOLID: * Einfacher Analysierbar / Lesbar * Flexibel * Wartbar</p> <p>Ein Entwurfsprinzip ist ein Prinzip, dass immer und st\u00e4ndig bei einem Entwurf von Designs / Architektur ber\u00fccksichtigt werden soll.</p>"},{"location":"architecture/principles/solid/#single-responsibility-priciples-srp","title":"Single Responsibility Priciples (SRP)","text":"<ul> <li>Ein beliebiges System (Methode, Klasse, Schicht) hat nur eine einzige Verantwortung/Aufgabe</li> <li>Vorteile: kurz, knapp, \u00fcbersichtlich, wenig komplex -&gt; einfach wartbar, lesbar</li> </ul> <p>Hilft durch das \"richtige\" schneiden von Bestandteilen der Software diese besser analysierbar, erweiterbar und damit austauschbar zu machen.</p>"},{"location":"architecture/principles/solid/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<ul> <li>Offen f\u00fcr Erweiterungen</li> <li>Geschlossen f\u00fcr Ver\u00e4nderungen</li> <li>Es werden Erweiterungspunkte geschaffen, sodass Quellcode nicht gro\u00df ge\u00e4ndert werden muss.</li> </ul> <p>Sorgt daf\u00fcr, dass die Anwendung erweiterbarer, modifizierbarer und so flexibler an die Projektsituation angepasst werden kann</p>"},{"location":"architecture/principles/solid/#liskov-subtitution-priciple-lsp","title":"Liskov Subtitution Priciple (LSP)","text":"<ul> <li>Definiert einen Implementierungs-Kontrakt</li> <li>Subklassen m\u00fcssen an die Stelle der Basisklasse treten k\u00f6nnen</li> </ul> <p>Stellt sicher, dass hinter einem kontrakt eine beliebige Implementierung genutzt werden kann, ohne dass der Aufrufer dies bemerkt.</p>"},{"location":"architecture/principles/solid/#interface-segregation-pricinple-isp","title":"Interface Segregation Pricinple (ISP)","text":"<ul> <li>Regelt die Granularit\u00e4t der Kontrakte</li> <li>Kontrakte immer f\u00fcr einzelne Konsumenten optimieren</li> </ul>"},{"location":"architecture/principles/solid/#dependency-inversion-pricinple-dip","title":"Dependency Inversion Pricinple (DIP)","text":"<ul> <li>Abh\u00e4ngigkeiten belasten alle relevanten Qualit\u00e4tsattribute</li> </ul> <p>Sorgt daf\u00fcr, dass in einer Anwendung keine Abh\u00e4ngigkeiten gegen Implementierung bestehen, sondern nur gegen Kontrakte</p>"},{"location":"coding/rule_of_three/","title":"Regel der Drei","text":"<p>Die \"Regel der Drei\" (eng. Rule of Three) is eine Faustregel in der Softwareentwicklung,  die besagt, dass wenn ein bestimmtes Muster oder eine bestimmte Struktur im Code zum dritten mal wiederkehrt, es an der Zeit ist, diese in eine abstrakte und wiederverwendbare Einheit zu extrahieren.</p> <p>Dies erh\u00f6ht die Wartbarkeit und Lesbarkeit des Codes. </p> <p>Somit wird Redundanz im Code vermieden und die Effizienz und Klarheit dieses gef\u00f6rdert.</p>"},{"location":"coding/rule_of_three/#quellen","title":"Quellen:","text":"<ul> <li>Wikipedia - Rule of three(computer programming)</li> <li>Western Oregon University - CS-161 Computer Science 1</li> </ul>"},{"location":"coding/tdd/","title":"TDD","text":"<p>dw--- title: Test driven Development date: 20240409 author: bresserbj</p>"},{"location":"coding/kotlin/maven/","title":"Maven","text":"<p>Maven ist ein Tool das zur Paketverwaltung in Java-Projekten eingesetzt werden kann um diese zu organisieren und auch um Automatisierungen einzubauen. </p>"},{"location":"coding/kotlin/maven/#project-object-model-pom","title":"Project Object Model - POM","text":"<p>Die Konfiguration eines Projektes, welches Maven einsetzt, wird mittels eines Projekt Object Models (POM) realisiert. Dieses PIM wird durch die pom.xml im Projekt-Root abgebildet. </p> <p>Diese Datei beschreibt...</p> <ul> <li>das Projekt</li> <li>Abhaengigkeiten zu Paketen</li> <li>Konfigurationen von Plugins</li> <li>Relationen zu Modulen anderer Projekte</li> </ul> <pre><code>&lt;project&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;example&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;com.example&lt;/name&gt;\n    &lt;url&gt;http://maven.apache.org&lt;/url&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n           //...\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n            //...\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#dependencies","title":"Dependencies","text":"<p>Abhaengigkeiten werden in der POM wie folgt definiert:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n    &lt;version&gt;5.3.16&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#properties","title":"Properties","text":"<p>Um eine Verbesserung der Wartbarkeit innerhalb der POM zu gewaehrleisten koennen zB Versionsnummern in properties  ueberfuehrt werden um diese wieder zu verwenden. So muss man nur einmal die Versionsnummer anpassen:</p> <pre><code>&lt;properties&gt;\n    &lt;spring.version&gt;5.3.16&lt;/spring.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n        &lt;version&gt;${spring.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;${spring.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#lifecycle","title":"Lifecycle","text":"<ul> <li>validate - Ueberprueft die Korrektheit des Projektes</li> <li>compile - Compiliert den SourceCode in ein Artefakt</li> <li>test - Ausfuehrung von Unittests</li> <li>package - Kompilierung des Codes</li> <li>integration-test - Tests, die auf den Paketen aufbauen</li> <li>verify - Validiert die Pakete</li> <li>install - Installiert die Pakete in das lokale Maven Repository</li> <li>deploy - Deployed die Pakete auf einen Remote Server oder in ein Repository</li> </ul>"},{"location":"coding/kotlin/maven/#wichtige-befehle","title":"Wichtige Befehle","text":"<p>Ein ausgefuehrter Befehl fuehrt auch immer die vorhergehenden notwendigen Punkte des Lifecycle aus.</p> Befehl Beschreibung mvn clean Cleans the project by deleting the target directory mvn compiler:compile Compiles the source classes mvn package Build the project and create the JAR/WAR files mvn install Build the project and install package files to local repository mvn deploy Deploy the build artifact to the remote repository mvn validate Validate the project is correct als everything is available mvn dependency:tree Generates the dependency tree of the project mvn dependency:analyze Analyze the project and identify the unused delcared dependencies mvn test Tests the source code mvn verify Run any checks on results of integration tests mvn compile compile the source code of the project"},{"location":"coding/macOs/environment/","title":"Environment","text":"<p>Diese Seite soll mir dabei helfen, Anforderungen an mein Macbook zu definieren und als Art Anleitung zum neuaufsetzen eines Macbooks.</p>"},{"location":"coding/macOs/environment/#anforderungen-an-mein-macbook","title":"Anforderungen an mein Macbook","text":"<ul> <li>Softwareentwicklung mit folgenden Frameworks, Technologien und Software<ul> <li>Kotlin</li> <li>Java</li> <li>Docker</li> <li>Gradle</li> <li>Python</li> <li>Git</li> <li>IntelliJ</li> </ul> </li> </ul>"},{"location":"coding/macOs/environment/#alfred","title":"Alfred","text":"<p>Alfred bietet eine effizientere Erweiterung fuer MacOs als die Spotlight-Suche vom Os selbst. Daher sollte die AlfredApp installiert werden: https://www.alfredapp.com/</p>"},{"location":"coding/macOs/environment/#brew","title":"Brew","text":"<p>Brew ist relativ einfach installiert. Man oeffnet das Terminal und gibt folgende Zeile ein</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Nachfolgend sind die weiteren Installationen relativ schnell erledigt.</p>"},{"location":"coding/macOs/environment/#softwareinstallationen-mit-brew","title":"Softwareinstallationen mit Brew","text":"<pre><code># GIT\nbrew install git\n\n# Docker\nbrew install docker\n</code></pre>"},{"location":"coding/macOs/environment/#terminal","title":"Terminal","text":"<p>Als Terminal faellt die Wahl auf iTerm2 mit einigen Modifikationen.</p> <pre><code>brew cask install iterm2\n</code></pre>"},{"location":"coding/macOs/environment/#zsh-oh-my-zsh","title":"zsh &amp; \"oh-my-zsh\"","text":"<p>Um zsh zu installieren nutzten wir im Terminal: </p> <pre><code>brew install zsh\n</code></pre> <p>Fuer eine Installation von oh-my-zsh nutzen wir nachfolgenden Befehl, wodurch das Standardterminal  anschliessend automatisch durch zsh ersetzt wird. </p> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"coding/macOs/environment/#install-fuck","title":"Install 'Fuck'","text":"<p>Eins der besten Plugins fuer Faule und Menschen die gerne Tippfehler in der Konsole begehen.ds</p> <pre><code>brew install thefuck\n</code></pre>"},{"location":"coding/macOs/environment/#wichtige-anpassungen","title":"Wichtige Anpassungen","text":"<p>Die zsh_fallout.json zu den Profilen hinzufuegen.</p>"},{"location":"coding/macOs/environment/#theme","title":"Theme","text":"<p>Zuerst muessen wir das Theme konfigurieren. Hierzu benoetigen wie einige Fonts etc.</p> <pre><code>sudo apt install fonts-powerline\n\ngit clone https://github.com/abertsch/Menlo-for-Powerline.git\ncd Menlo-for-Powerline\ncp \"Menlo for Powerline.ttf\" ~/.fonts\n</code></pre> <pre><code>vi ~/.zshrc\n\n# Set name of the theme to load --- if set to \"random\", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME=\"agnoster\"\n</code></pre>"},{"location":"coding/macOs/environment/#plugins","title":"Plugins","text":"<p>Um externe Plugins zu installieren kann dieser Befehl genutzt werden <pre><code>git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions\n</code></pre></p> <pre><code>vi ~/.zshrc\n\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(\n  git\n  github\n  brew\n  docker\n  npm\n  macos\n  bgnotify\n  zsh-syntax-highlighting\n  zsh-autosuggestions\n  web-search\n)\n</code></pre>"},{"location":"coding/macOs/environment/#alias-parameter","title":"Alias Parameter","text":"<pre><code>vi ~/.zshrc\n\n# Example aliases\n# alias zshconfig=\"mate ~/.zshrc\"\n# alias ohmyzsh=\"mate ~/.oh-my-zsh\"\n\nalias zshconfig=\"nano ~/.zshrc\"\nalias ohmyzsh=\"nano ~/.oh-my-zsh\"\nalias gpf='git push -f'\n\n# Docker alias\nalias dkps=\"docker ps\"\nalias dkst=\"docker stats\"\nalias dkpsa=\"docker ps -a\"\nalias dkimgs=\"docker images\"\nalias dkcpup=\"docker-compose up -d\"\nalias dkcpdown=\"docker-compose down\"\nalias dkcpstart=\"docker-compose start\"\nalias dkcpstop=\"docker-compose stop\"\n\n# Kubectl alias\nalias kdev='kubectl -n dev'\nalias kpg='kubectl -n playground'\nalias ktest='kubectl -n test'\nalias kprod='kubectl -n prod'\nalias kpreprod='kubectl -n preprod'\nalias vpnstart='~/Scripts/vpn-start.sh'\nalias vpn-start='~/Scripts/vpn-start.sh'\n\neval $(thefuck --alias)\n</code></pre>"},{"location":"coding/macOs/environment/#macbook-shortcuts","title":"Macbook shortcuts","text":"<p>TBD</p>"}]}