{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Startingpoint","text":"<p>This page is deliberately kept in German, as I needed a place for myself and my notes, learning experiences, etc.</p> <p>Maybe I'll translate them at some point.</p>"},{"location":"#mein-kleiner-digitaler-garten","title":"Mein kleiner \"Digitaler Garten\"","text":"<p>Wissen hei\u00dft wissen, wo es geschrieben steht</p> <p>Albert Einstein - deutsch-amerikanischer Physiker</p> <p>Das ist das Motto, dass ich mehr oder weniger pflege - beruflich wie auch privat.</p> <p>Immer wieder \"erwische\" ich mich dabei, dass ich die gleichen Antworten, unabh\u00e4ngig vom beruflichen oder  privaten Umfeld, im Internet nachschlage, anwende und vergesse. Dies f\u00fchrt dazu, dass ich zu einem sp\u00e4teren Zeitpunkt wieder genau die gleiche Zeile in die Suchmaschine meiner Wahl tippe und hoffe, DIE Antwort wieder zu finden, die beim letzten Mal so gut funktionierte.</p> <p>Das ein oder andere Mal versagte dies bereits und deswegen \u00fcberlegte ich, wie dies zu \u00e4ndern sein.</p> <p>Entsprechend ist diese Seite entstanden, die wissen f\u00fcr mich festh\u00e4lt, die ich stetig erweitern sowie konsultieren kann.</p>"},{"location":"architecture/ddd_glossary/","title":"Domain Driven Design - Glossar","text":"Begriff Definition Beispiel ACID Properties ACID steht f\u00fcr die vier grundlegenden Eigenschaften einer Transaktion: Atomicity (Atomarit\u00e4t), Consistency (Konsistenz), Isolation (Isolation) und Durability (Dauerhaftigkeit). Ein Bankensystem stellt sicher, dass \u00dcberweisungen nach den ACID-Eigenschaften durchgef\u00fchrt werden, sodass keine Gelder verloren gehen, selbst wenn das System abst\u00fcrzt. Aggregate Ein Aggregate ist eine Gruppe von zusammenh\u00e4ngenden Entit\u00e4ten und Werten, die als eine Einheit behandelt werden. Es stellt sicher, dass Gesch\u00e4ftsregeln innerhalb des Aggregates eingehalten werden. Ein Order-Aggregate enth\u00e4lt Bestellpositionen und Zahlungsinformationen. Aggregate Root Die Aggregate Root ist die zentrale Entit\u00e4t innerhalb eines Aggregates, \u00fcber die alle Operationen (z. B. Hinzuf\u00fcgen, L\u00f6schen) durchgef\u00fchrt werden. Sie verwaltet die Konsistenz des Aggregates. <code>Order</code> ist die Aggregate Root des Order-Aggregates. Anti-Corruption Layer (ACL) Ein Anti-Corruption Layer ist eine Schicht, die die Kommunikation zwischen verschiedenen Bounded Contexts erleichtert, ohne dass der Code in einem Kontext von einem anderen \"korrumpiert\" wird. Ein PaymentAdapter k\u00f6nnte als Anti-Corruption Layer fungieren, um die Kommunikation zwischen dem SalesBoundedContext und einem externen Zahlungsanbieter zu erm\u00f6glichen. Bounded Context Ein Bounded Context ist ein klar definierter Bereich innerhalb einer Anwendung, in dem ein bestimmtes Modell und eine gemeinsame Sprache verwendet werden. Es hilft, verschiedene Teile eines Systems voneinander zu trennen. Ein SalesBoundedContext, in dem die Verkaufslogik f\u00fcr Bestellungen und Kunden definiert ist, getrennt vom InventoryBoundedContext, der sich mit Lagerbest\u00e4nden befasst. Command Ein Command ist eine Anweisung, die eine Ver\u00e4nderung des Systems bewirken soll. Commands sind meistens von au\u00dfen initiierte Aktionen. Ein PlaceOrderCommand, das eine neue Bestellung in einem System ausl\u00f6st. Consistency Boundary Die Consistency Boundary bezeichnet die Grenze innerhalb eines Systems, bei der alle relevanten Daten in einer konsistenten Weise miteinander verbunden sind. Sie wird h\u00e4ufig mit Aggregaten und Transaktionen in Verbindung gebracht. Das Order-Aggregate hat eine Konsistenzgrenze: \u00c4nderungen an den Bestellpositionen m\u00fcssen sicherstellen, dass keine ung\u00fcltigen Bestellungen entstehen. Context Map Eine Context Map ist eine Darstellung der Beziehungen zwischen verschiedenen Bounded Contexts innerhalb einer Anwendung und zeigt, wie sie miteinander kommunizieren. Eine Karte, die zeigt, dass der SalesBoundedContext mit dem PaymentBoundedContext kommuniziert, um Zahlungen zu verarbeiten. CQRS (Command Query Responsibility Segregation) CQRS ist ein Muster, das die Trennung von Lese- und Schreiboperationen in ein System fordert. Ein Teil des Systems ist f\u00fcr das Schreiben zust\u00e4ndig (Commands), ein anderer f\u00fcr das Lesen (Queries). Ein System, das CQRS verwendet, hat separate Komponenten f\u00fcr das Erstellen und Abfragen von Bestellungen. DAO (Data Access Object) Ein DAO ist eine Designpattern, das den Zugriff auf die Datenbank kapselt und CRUD-Operationen (Create, Read, Update, Delete) bereitstellt. DAO k\u00fcmmert sich um die Datenpersistenz. Ein UserDAO, das einfache Methoden wie <code>save()</code>, <code>findById()</code>, <code>delete()</code> f\u00fcr eine <code>User</code>-Entit\u00e4t bereitstellt. Database Migration Eine Datenbankmigration ist der Prozess, bei dem die Struktur einer Datenbank \u00fcber Zeit ver\u00e4ndert wird, oft durch das Erstellen von neuen Tabellen oder das Aktualisieren bestehender Strukturen. Die Flyway-Bibliothek kann verwendet werden, um Datenbankmigrationen zu verwalten, wenn sich das Datenbankschema w\u00e4hrend der Entwicklung \u00e4ndert. Dependency Injection Dependency Injection (DI) ist ein Entwurfsmuster, bei dem Objekte ihre Abh\u00e4ngigkeiten (z. B. Services, Repositories) zur Laufzeit von au\u00dfen erhalten, anstatt sie selbst zu erzeugen. In einer Spring-Anwendung wird der OrderService durch DI mit einem OrderRepository ausgestattet. Domain Event Ein Domain Event ist ein Ereignis, das eine wichtige Ver\u00e4nderung im Zustand der Dom\u00e4ne darstellt und h\u00e4ufig in einer anderen Umgebung (z. B. ein anderes System) behandelt wird. Ein OrderPlacedEvent, das ausgel\u00f6st wird, wenn eine Bestellung erfolgreich abgeschlossen wurde. Entity Eine Entity ist ein Objekt, das eine eindeutige Identit\u00e4t hat und im Laufe der Zeit ver\u00e4ndert werden kann. Der Zustand einer Entity kann sich \u00e4ndern, aber ihre Identit\u00e4t bleibt immer gleich. Ein User-Objekt in einer Anwendung, das durch eine Benutzer-ID eindeutig identifiziert wird. Event Sourcing Event Sourcing ist ein Muster, bei dem alle \u00c4nderungen des Systemzustands als eine Serie von Ereignissen (Domain Events) gespeichert werden, anstatt den aktuellen Zustand direkt zu speichern. Bei einer Bestellung werden alle OrderPlacedEvent, ItemAddedEvent und PaymentProcessedEvent gespeichert, anstatt nur die aktuellen Bestelldaten. Eventual Consistency Eventual Consistency ist ein Prinzip, bei dem das System nach einer gewissen Zeit in einen konsistenten Zustand zur\u00fcckkehrt, auch wenn w\u00e4hrend der Operationen vor\u00fcbergehende Inkonsistenzen bestehen k\u00f6nnen. In einem verteilten System kann es zu einer vor\u00fcbergehenden Inkonsistenz zwischen verschiedenen Services kommen, aber nach einiger Zeit wird das System wieder konsistent. Factory Eine Factory ist eine Dom\u00e4nenklasse, die f\u00fcr die Erstellung von Aggregaten oder Entit\u00e4ten verantwortlich ist, insbesondere wenn die Erstellung komplex ist oder viele Schritte erfordert. Eine OrderFactory, die neue Bestellungen unter Ber\u00fccksichtigung von Gesch\u00e4ftsregeln erstellt. Read Model Ein Read Model ist eine speziell gestaltete Repr\u00e4sentation der Daten, die f\u00fcr Leseoperationen optimiert ist. H\u00e4ufig wird es im Zusammenhang mit CQRS (Command Query Responsibility Segregation) verwendet. Ein OrderReadModel, das alle relevanten Daten f\u00fcr die Anzeige der Bestellung im UI enth\u00e4lt. Repository Ein Repository ist eine Schnittstelle, die f\u00fcr das Abrufen und Speichern von Aggregaten verantwortlich ist. Es kapselt den Zugriff auf die Persistenzschicht. Ein OrderRepository, das <code>Order</code>-Aggregates aus der Datenbank abruft und speichert. Saga Eine Saga ist ein langfristiger Gesch\u00e4ftsprozess, der aus einer Reihe von lokalisierten Transaktionen besteht. Wenn eine Transaktion fehlschl\u00e4gt, m\u00fcssen alle vorherigen Transaktionen r\u00fcckg\u00e4ngig gemacht werden. Eine OrderProcessingSaga, die aus mehreren Schritten wie Bestellannahme, Lagerreservierung und Zahlungsabwicklung besteht. Service Ein Service ist eine Dom\u00e4nenklasse, die Gesch\u00e4ftslogik kapselt, die nicht nat\u00fcrlich zu einer Entity oder einem Value Object geh\u00f6rt. Ein PaymentService, der die Logik zur Verarbeitung von Zahlungen enth\u00e4lt. Transaction Eine Transaktion stellt sicher, dass eine Reihe von Datenbankoperationen als atomare Einheit ausgef\u00fchrt werden. Entweder alle Operationen werden erfolgreich ausgef\u00fchrt oder keine. Eine OrderTransaction, die das Erstellen einer Bestellung und das Hinzuf\u00fcgen von Bestellpositionen in einer einzigen Transaktion durchf\u00fchrt. Ubiquitous Language Eine Ubiquitous Language ist eine Sprache, die von allen Beteiligten (Entwickler, Dom\u00e4nenexperten, Stakeholder) verwendet wird, um die Begriffe und Konzepte der Dom\u00e4ne zu beschreiben und zu verstehen. Das gesamte Team verwendet denselben Begriff wie Order, Payment, Customer, um klar und eindeutig zu kommunizieren. Value Object Ein Value Object ist ein unver\u00e4nderliches Objekt, das keine eigene Identit\u00e4t hat. Es wird nur durch seine Eigenschaften beschrieben. Eine Adresse in einer Bestellung, die keine eigene Identit\u00e4t hat, aber durch Stra\u00dfenname, Stadt und Postleitzahl definiert wird. Write Model Ein Write Model ist das Modell, das die Logik f\u00fcr Schreiboperationen und Zustands\u00e4nderungen eines Systems kapselt. Es wird oft mit einem Command verwendet. Ein OrderWriteModel, das die Logik f\u00fcr das Erstellen und Bearbeiten von Bestellungen enth\u00e4lt."},{"location":"architecture/domain_driven_design/","title":"Domain Driven Design","text":"<p>Domain Driven Design (DDD) kann man grob in zwei Segmente von Tools unterteilen: strategisch und taktisch. Sowohl die strategischen als auch taktischen Muster und Praktiken von DDD richten die Softwarearchitektur auf  das Geschaeftsmodell (Business) aus.</p> <p>Strategische Aspekte von DDD beantworten die Fragen des \"Was?\" und \"Wieso?\", waehrend die taktischen Aspekte das \"Wie?\" beschreiben.</p> <p>Strategisch -  Die strategischen Tools von DDD werden benutzt um die Business Domains und Strategie des Unternehmens zu identifizieren. Auf Basis des Wissens der Business Domains kann anschliessend eine \"high level\" design Entscheidung getroffen werden, wie man die Systeme in einzelne Komponenten zerlegt und daraufhin Integrationsmuster definiert.</p> <p>Taktisch -  Die taktischen Werkzeuge von DDD befassen sich mit einem anderen Aspekt der Probleme. Mit diesen Mustern kann Code auf  eine Art und Weise geschrieben werden, der die Anwendungsdomaine widerspiegelt, ihre Ziele anspricht und die Sprache des Unternehmens spricht.</p>"},{"location":"architecture/domain_driven_design/#strategisch","title":"Strategisch","text":"<p>Um eine effiziente Loesung du entwickeln muss man zuerst das Problem verstanden haben. In diesem Fall ist das Problem die Software, die es zu bauen gilt.</p> <p>Unternehmen arbeiten in Geschaeftsfeldern (Business Domain).  Ein Gesch\u00e4ftsfeld (Business Domain) definiert den Hauptt\u00e4tigkeitsbereich eines Unternehmens. Es ist die Dienstleistung, die das Unternehmen f\u00fcr seine Kunden erbringt.</p> <p>Um die Ziele seines Geschaefsfelds zu erfuellen ist es fuer Unternehmen notwendig seine Aktivitaeten in Subdomains aufzuteilen. Alle Subdomains gemeinsam formen die Business Domain.</p>"},{"location":"architecture/domain_driven_design/#subdomains","title":"Subdomains","text":"<p>Eine Subdomain wird in drei Typen unterteilt: Core, Generic und Supporting Subdomains sind hierbei wie Karten eines Kartenhauses zu sehen: Nimmt man eine Karte weg faellt die Struktur in sich zusammen.</p> <ul> <li>Core Subdomains spiegeln den kompetativen Vorteil des Unternehmens in seiner Branche wieder.</li> <li>Generic Subdomains, bieten keinen kompetativen Vorteil und koennen auch von anderen Unternehmen so genutzt werden.</li> <li>Supporting Subdomains bieten keinen kompetativen Vorteil, haben aber eine niedrige Einstiegshuerde.</li> </ul> <p>Um zwischen diesen Typen unterscheiden zu koennen macht es Sinn die nachfolgende Tabelle zu beruecksichtigen:</p> Subdomain type Competitive advantage Complexity Volatility Implementation Problem Core Yes High High Inhouse Interesting Generic No High Low Buy Solved Supporting No Low Low Inhouse/Outsource Obvious"},{"location":"architecture/domain_driven_design/#domain-knowledge","title":"Domain Knowledge","text":"<p>Um effiziente Software zu entwickeln, die die Beduerfnisse des Businesses abdeckt, ist es wichtig das Grundwissen ueber  die Business Domain zu erlangen. Dafuer ist es wichtig die Domain Experten zu verstehen, vor Allem wie diese ueber das  Problem denken. Ohne dieses Verstaendnis und die Gruende hinter den Anforderungen ist es nicht moeglich alle Aspekte  des Business abzudecken. </p> <p>Der Schluessel hierzu liegt in der Kommunikation und der Schaffung einer gemeinsamen Sprache die ein gemeinsames  Verstaendnis bildet, ohne \"Ubersetzungen\" weiterer Parteien - dies wuerde nur dazu fuehren das falsche Loesungen  implementiert werden oder die richtigen Loesungen zu den falschen Problemen.</p>"},{"location":"architecture/domain_driven_design/#ubiquitous-language","title":"Ubiquitous Language","text":"<p>Eine allgegenwaertige Sprache ist der Grundpfeiler von Domain Driven Design und laesst sich leicht so erklaeren:</p> <p>Wenn Parteien effizient miteinander kommunizieren sollen, muessen diese die gleiche Sprache sprechen.</p> <p>Die Sprache respresentiert in diesem Fall die Business Domain als auch das mentale Model des Domain Experten. Sie ist  vor Allem die Sprache des Businesses und sollte entsprechend nur Begriffe umfassen die in Verbindung mit der Business Domain stehen - kein technischer Jargon!</p> <p>Auch ist bei der allgegenwaertigen Sprache auf konsistenz zu achten. Sie soll praezise sein und jeder Begriff soll nur eine Bedeutung haben; sie koenne nicht austauschbar verwendet werden. Jeder Begriff ist ausdruecklich in seinem  spezifischem Zusammenhang zu verwenden.</p> <p>Beispiel:</p> <p>\"Verkaufsprovisionen werden nach Genehmigung der Transaktion verbucht.\"</p> <p>nicht</p> <p>\"Die Verkaufsprovisionen basieren auf korrelierten Datensaetzen aus den Tabellen der Transaktionen und der genehmigten Verkaeufe.\"</p>"},{"location":"architecture/domain_driven_design/#model-der-business-domain","title":"Model der Business Domain","text":"<p>A model is a simplified representation of a thing or phenomenon that intentionally emphasizes certain aspects while  ignoring others. Abstraction with a specific use in mind.</p> <p>-- Rebecca Wirfs-Brock</p> <p>Alle Modelle haben einen Zweck, der nur die Details enthaelt, die zur Erfuellung dieses Zwecks erforderlich sind. Ein Model soll hierbei ein Problem loesen, mit grade mal genug Informationen fuer diesen Zweck. </p> <p>Die allgegenwaertige Sprache die wir verwenden ist nicht detailiert genug um die Domaine abzudecken. Das ist der Zweck des Modells, das gerade genug Aspekte der Business Domain enthalten soll, um eine Implementierung des erforderlichen  Systems zu ermoeglichen.</p>"},{"location":"architecture/domain_driven_design/#tools","title":"Tools:","text":"<p>Ein Tool um die Business Domain besser zu verstehen ist ein Glossar, wobei dieses vorrangig fuer Nomen verwendet werden  kann und damit teilweise nicht die noetige Detailtiefe beinhaltet die man benoetigt.</p> <p>Ein anderes Tool sind Gherkin Tests. Tests geschrieben in Gherkin sind ein grossartiges Tool um die Sprache der  Business Domain abzubilden und um gleichzeitig die Luecken zwischen dem Domain Experten und den Entwicklern zu schliessen.</p> <p>Beispiel:</p> <pre><code>Scenario: Notify the agent about a new support case\n    Given Vicent Jules submits a new support case says:\n    \"\"\"\n    I need help configuring AWS Infinidash\n    \"\"\"\n    When the ticket is assigned to Mr. Wolf\n    Then the agent receives a notification about the new ticket\n</code></pre>"},{"location":"architecture/domain_driven_design/#bounded-contexts","title":"Bounded Contexts","text":"<p>Die allgegenwaertige Sprache soll konsistent, eineindeutig und praezise sein. Es kann allerdings vorkommen, dass dies  nicht direkt moeglich ist, da zB mehrere Subdomains die gleichen Begrifflichkeiten anders nutzen. Hier gaebe es die  Moeglichkeit diese Begriffe zB ueber einen Prefix zu differenzieren und entsprechend in der Implementierung zwei Modelle  zu nutzen, was allerdings zu kognitivem Overload fuehren wird. </p> <p>An dieser Stelle kommt der \"Bounded Context\" ins Spiel der sich dieser Problematik annimmt. Dieser teilt die definierte allgegenwaertige Sprache in mehrere kleinere Sprachen auf, die in ihrem Kontext eineindeutig werden. Es werden der allgegenwaertigen Sprache also Grenzen gesteckt welche ebenfalls auf die Models angewandt werden.</p> <p>Also kann man sagen, dass die allgegenwaertige Sprache nocht allgegenwaertig ist und nicht universel. Erst durch die  Nutzung dieser Sprache in Verbindung mit einem Bounded Context wird dies erfuellt werden.</p>"},{"location":"architecture/domain_driven_design/#physical-boundaries","title":"Physical Boundaries","text":"<p>Der Bounded Context fungiert hier nicht nur als Grenze fuer die Models, sondern kann auch physisch genutzt werden. Jeder definierte Bounded Context sollte also als eigener Service oder eigenes Projekt implementiert werden. Somit kann jedem Bounded Context in Bezug auf die Implementierung der Techstack zugeordnet werden, welchen er benoetigt.</p>"},{"location":"architecture/domain_driven_design/#taktisch","title":"Taktisch","text":""},{"location":"architecture/goal/","title":"Software Architecture","text":""},{"location":"architecture/goal/#ziele-einer-softwarearchitektur","title":"Ziele einer Softwarearchitektur","text":"<p>Das Ziel einer Softwarearchitektur ist die Aufteilung eines Systems in Komponenten sowie die Anordung und Eigenschaften dieser Komponenten nd wie diese miteinander kommunizieren.</p> <p>Hierbei sollte eine gute Architektur laut Robert C. Martin die Eigenschaft erfuellen waehrend  ihrer Lebenszeit mit moeglichst geringem und gleichbleibendem Aufwand veraenderbar zu sein.</p>"},{"location":"architecture/hexagonal_architecture/","title":"Hexagonal Architecture","text":""},{"location":"architecture/hexagonal_architecture/#was-ist-eine-hexagonale-architektur","title":"Was ist eine Hexagonale Architektur?","text":"<p>Eine Hexagonale Architektur, oder auch \"Ports und Adapter\" genannt, zeichnet sich laut des Autors Alistair Cockburn durch nachfolgende drei Ziele aus:</p> <ol> <li>Es soll keinen Unterschied machen ob die Businesslogik von einer UI, einer API oder einem Test-Framework aufgerufen wird.</li> <li>Die Businesslogik soll isoliert von der Datenbank und sonstiger Infrastruktur oder Drittsystemene entwickelt und    getestet werden koennen. </li> <li>Aenderungen an externen Schnittstellen oder Modernisierungen der Infrastruktur sollen ohne Anpassungen an der     Businesslogik moeglich sein.</li> </ol>"},{"location":"architecture/hexagonal_architecture/#ports-und-adapter","title":"Ports und Adapter","text":"<p>Erreicht werden diese drei Ziele durch die Isolation der Businesslogik ueber sogenannte \"Ports\" und \"Adapter\".</p> <p>Die Businesslogik liegt im Kern der Anwendung und definiert \"Ports\" um von ausserhalb gesteuert zu werden und um zu steuern. Wichtig ist es, dass es der Businesslogik irrelevant ist, welche technischen Details sich hinter den Ports befinden. Alle Komponenten ausserhalb des Kerns sind gegen die Ports zu implementieren.</p> <p>Die Anbindung der externen Komponente erfolgt durch \"Adapter\".</p> <p>Applikation \u2192 Port \u2192 Database Adapter \u2192 Database</p> <p>An einem Port koennen mehrere Adapter angeschlossen werden. So kann zB. an einen Port zur Steuerung einer Anwendung  ein Adapter fuer die UI und ein Adapter fuer eine API angeschlossen sein.</p>"},{"location":"architecture/hexagonal_architecture/#steuernde-und-gesteuerte-ports","title":"Steuernde und gesteuerte Ports","text":"<p>Es gibt zwei Arten von Ports nd Adaptern - steuernde und gesteuerte. Steuernde Ports und Adapter werden auch als \"driving\" oder \"primary\" bezeichnet. Gesteuerte Ports werden als \"driven\" oder \"secondary\" bezeichnet.</p>"},{"location":"architecture/hexagonal_architecture/#dependency-rule","title":"Dependency Rule","text":"<p>Um die technischen Details und Anbindungen zur Anwendung abzutrennen koenne nwir die sogenannte \"Dependency Rule\" nutzen. Diese besagt, dass Abhaengigkeiten ausschliesslich von aussen nach innen, also in Richtung der Anwendung zeigen duerfen.</p> <p>Adapter: <pre><code>package com.bank.transfer.infrastructure.adapter.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\nclass TransferController(\n   private val transferMoneyPort: TransferMoney\n) {\n\n   fun transfer(amount: BigDecimal, from: UUID, to: UUID): TransferMoneyRespone {\n      return transferMoneyPort.transfer(TransferMoneyRequest(amount, from, to))\n   }\n}\n</code></pre> Port: <pre><code>package com.bank.transfer.app.port.driver\n\nimport java.math.BigDecimal\nimport java.util.UUID\n\ninterface TransferMoney {\n   fun transfer(request: TransferMoneyRequest): TransferMoneyRespone\n}\n\ndata class TransferMoneyRequest(\n   val amount: BigDecimal,\n   val from: UUID,\n   val to: UUID\n)\n\nsealed class TransferMoneyResponse {\n   object Success : TransferMoneyResponse()\n   object InvalidAmount : TransferMoneyResponse()\n}\n</code></pre></p> <p>Service: <pre><code>package com.bank.transfers.app.service\n\nclass TransferService : TransferMoney {\n   override fun transfer(request: TransferMoneyRequest): TransferMoneyRespone {\n      TODO(\"Not yet implemented\")\n   }\n\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dependency-inversion","title":"Dependency Inversion","text":"<p>Auch hier wird der Port durch ein Interface definiert. Allerdings sind die Beziehungen zwischen den Klassen vertauscht. Der Adapter benutzt den Port nicht, sondern implementiert diesen und der Service implementiert den Port nicht sondern benutzt ihn.</p> <p>Port: <pre><code>package com.bank.transfers.app.port.driven\n\ninterface AccountFinder {\n    fun find(customerId: CustomerId): Account?\n}\n</code></pre></p> <p>Adapter <pre><code>package com.bank.transfers.infrastructure.adapter.driven\n\nclass InMemoryAccounts : AccountFinder {\n    private val accounts = mutableMapOf&lt;CustomerId, Account&gt;()\n\n   override fun find(customerId: CustomerId): Account? = accounts.get(customerId)\n}\n</code></pre></p> <p>Services: <pre><code>package com.bank.transfers.app.service\n\nclass AccountService(private val accountFinder: AccountFinder) {\n   override fun find(customerId: CustomerId) {\n      TODO(\"Not yet implemented\")\n   }\n}\n</code></pre></p>"},{"location":"architecture/hexagonal_architecture/#dilemma-der-isolation","title":"Dilemma der Isolation","text":"<p>Die Isolierung der technischen Details fuehrt dazu, dass bei der Verwendung von ORM ein Dilemma darin besteht, dass der  Kern der Anwendung die Details des Persistierenden Adapters nicht kennen soll, also die Entitaet. </p> <p>Hier gibt es einen Loesungsansatz indem man zum einen die Klasse der Entitaet im Adapter hat, die keine Businesslogik beinhaltet, aber dafuer die technischen Annotationen fuer die Persistierung, und zum Anderen dem Kern der Anwendung eine eigene Modelklasse implementiert.</p> <p>Das gleiche Dilemma finden wir auch in API-Adaptern, die oft nicht alle Attribute einer Entitaet sichtbar machen sollen.</p>"},{"location":"architecture/hexagonal_architecture/#vorteile-der-hexagonalen-architektur","title":"Vorteile der Hexagonalen Architektur","text":"<ul> <li>Aenderbarkeit - Die Businesslogik kann geaendert werden ohne die Adapter oder Infrastruktur aendern zu muessen und umgekehrt.</li> <li>Isolierung - Der Kern der Anwendung umfasst nur fachliche Themen und technische Themen sind in den Adaptern implementiert.</li> <li>Entwicklung - Entwicklung an Komponenten kann aufgeteilt werden.</li> <li>Testbarkeit - Komponenten koennen vollstaendig isoliert geteste werden.</li> </ul>"},{"location":"architecture/hexagonal_architecture/#nachteile-der-hexagonalen-architektur","title":"Nachteile der Hexagonalen Architektur","text":"<ul> <li>Erheblicher Mehraufwand der sich fur CRUD-Microservices eher nicht lohnt.</li> </ul>"},{"location":"architecture/principles/dry/","title":"DRY","text":"<p>DRY steht f\u00fcr \"Don't Repeat Yourself\". </p> <p>Bedeutet, dass man wiederholende Logik, Code und Muster zugunsten modularer referenzierbarem Codes reduzieren sollte</p>"},{"location":"architecture/principles/dry/#warum-dry","title":"Warum DRY?","text":"<p>DRY hilft dabei lesbareren und wartbareren Code zu produzieren.</p>"},{"location":"architecture/principles/dry/#wann-ist-es-dry-genug","title":"Wann ist es \"DRY\" genug?","text":"<p>Als Faustregel kann man hier die \"Regel der Drei\" (eng. Rule of Three) nutzen. Diese besagt, dass beim dritten Mal, wenn man auf ein bestimmtes Muster st\u00f6\u00dft, dieses wahrscheinlich wiederverwendbar abstrahiert werden sollte.</p>"},{"location":"architecture/principles/dry/#zusammenfassung","title":"Zusammenfassung","text":"<p>DRY ist ein Prinzip das immer angestrebt werden sollte.  Es spart Aufwand, erh\u00f6ht die Lesbarkeit, Wartbarkeit und Qualit\u00e4t des Quellcode. </p>"},{"location":"architecture/principles/dry/#referenzen","title":"Referenzen","text":"<ul> <li>getDbt - Dry</li> </ul>"},{"location":"architecture/principles/principles/","title":"Prinzipien","text":""},{"location":"architecture/principles/principles/#muster-patterns","title":"Muster / Patterns","text":"<p>Muster/Pattern werden immer dann verwendet, wenn man in einem ganz konkreten Szenario ein Problem hat, dass zu einem fixen Zeitpunkt, an einer definierten Stelle gel\u00f6st werden soll.</p>"},{"location":"architecture/principles/principles/#beispiele","title":"Beispiele","text":"<ol> <li>Ein Austausch eines Algorithmus zur Projektlaufzeit an einer definierten Stelle im Code -&gt; Strategy Design Pattern</li> <li>Ausf\u00fchrung einer hochskalierbaren einzelnen Funktion innerhalb der Clode -&gt; Serverless Architecture Pattern</li> </ol>"},{"location":"architecture/principles/principles/#prinzipien","title":"Prinzipien","text":"<p>Prinzipien sind wie Muster/Patterns, es hilft bei der L\u00f6sung von Probleme. Dies geschieht allerdings nicht wie bei  dem Mustern/pattern zu einem fixen Zeitpunkt an einer definierten Stelle, sondern geschieht kontinuierlich \u00fcber einen l\u00e4ngeren Zeitraum auf verschiebene Ebenen.</p>"},{"location":"architecture/principles/principles/#beispiel","title":"Beispiel","text":"<ol> <li>Es soll vermieden werden doppelten Quellcode zu erzeugen -&gt; DRY-Prinzip</li> </ol>"},{"location":"architecture/principles/principles/#zusammenfassung","title":"Zusammenfassung","text":"<p>Ein Prinzip ist eine Regel bzw. ein Gesetz, das in der Entwicklung zu jedem Zeitpunkt einzuhalten ist und welches der Software bestimmte Eigenschaften hinzuf\u00fcgt.</p> <p>Ein Prinzip addressiert hierbei ein Qualit\u00e4tsmerkmal der Software wie z.B. die Lesbarkeit von Quellcode, Erweiterbarkeit von Anwendungen, Wartbarkeit etc.</p> <p>Prinzipien k\u00f6nnen untereinander konkurrieren.</p>"},{"location":"architecture/principles/solid/","title":"SOLID","text":""},{"location":"architecture/principles/solid/#solid","title":"SOLID","text":"<p>Alle Prinzipien von SOLID sind \"Entwurfsprinzipien\"</p> <p>Qualit\u00e4tsmerkamel von SOLID: * Einfacher Analysierbar / Lesbar * Flexibel * Wartbar</p> <p>Ein Entwurfsprinzip ist ein Prinzip, dass immer und st\u00e4ndig bei einem Entwurf von Designs / Architektur ber\u00fccksichtigt werden soll.</p>"},{"location":"architecture/principles/solid/#single-responsibility-priciples-srp","title":"Single Responsibility Priciples (SRP)","text":"<ul> <li>Ein beliebiges System (Methode, Klasse, Schicht) hat nur eine einzige Verantwortung/Aufgabe</li> <li>Vorteile: kurz, knapp, \u00fcbersichtlich, wenig komplex -&gt; einfach wartbar, lesbar</li> </ul> <p>Hilft durch das \"richtige\" schneiden von Bestandteilen der Software diese besser analysierbar, erweiterbar und damit austauschbar zu machen.</p>"},{"location":"architecture/principles/solid/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<ul> <li>Offen f\u00fcr Erweiterungen</li> <li>Geschlossen f\u00fcr Ver\u00e4nderungen</li> <li>Es werden Erweiterungspunkte geschaffen, sodass Quellcode nicht gro\u00df ge\u00e4ndert werden muss.</li> </ul> <p>Sorgt daf\u00fcr, dass die Anwendung erweiterbarer, modifizierbarer und so flexibler an die Projektsituation angepasst werden kann</p>"},{"location":"architecture/principles/solid/#liskov-subtitution-priciple-lsp","title":"Liskov Subtitution Priciple (LSP)","text":"<ul> <li>Definiert einen Implementierungs-Kontrakt</li> <li>Subklassen m\u00fcssen an die Stelle der Basisklasse treten k\u00f6nnen</li> </ul> <p>Stellt sicher, dass hinter einem kontrakt eine beliebige Implementierung genutzt werden kann, ohne dass der Aufrufer dies bemerkt.</p>"},{"location":"architecture/principles/solid/#interface-segregation-pricinple-isp","title":"Interface Segregation Pricinple (ISP)","text":"<ul> <li>Regelt die Granularit\u00e4t der Kontrakte</li> <li>Kontrakte immer f\u00fcr einzelne Konsumenten optimieren</li> </ul>"},{"location":"architecture/principles/solid/#dependency-inversion-pricinple-dip","title":"Dependency Inversion Pricinple (DIP)","text":"<ul> <li>Abh\u00e4ngigkeiten belasten alle relevanten Qualit\u00e4tsattribute</li> </ul> <p>Sorgt daf\u00fcr, dass in einer Anwendung keine Abh\u00e4ngigkeiten gegen Implementierung bestehen, sondern nur gegen Kontrakte</p>"},{"location":"coding/rule_of_three/","title":"Regel der Drei","text":"<p>Die \"Regel der Drei\" (eng. Rule of Three) is eine Faustregel in der Softwareentwicklung,  die besagt, dass wenn ein bestimmtes Muster oder eine bestimmte Struktur im Code zum dritten mal wiederkehrt, es an der Zeit ist, diese in eine abstrakte und wiederverwendbare Einheit zu extrahieren.</p> <p>Dies erh\u00f6ht die Wartbarkeit und Lesbarkeit des Codes. </p> <p>Somit wird Redundanz im Code vermieden und die Effizienz und Klarheit dieses gef\u00f6rdert.</p>"},{"location":"coding/rule_of_three/#quellen","title":"Quellen:","text":"<ul> <li>Wikipedia - Rule of three(computer programming)</li> <li>Western Oregon University - CS-161 Computer Science 1</li> </ul>"},{"location":"coding/tdd/","title":"TDD","text":"<p>dw--- title: Test driven Development date: 20240409 author: bresserbj</p>"},{"location":"coding/kotlin/jooq/","title":"Joop","text":""},{"location":"coding/kotlin/jooq/#was-ist-jooq","title":"Was ist jOOQ?","text":"<p>jOOQ bietet eine typesichere, DSL-aehnliche API, mit der SQL-Abfragen direkt umgesetzt werden koennen. Anders als andere ORM-Frameworks wie zB Hibernate, setzt es hier darauf SQL auf eine praegnaten und saubere  Weise direkt in den Code zu integrieren, anstatt SQL zu abstrahieren.</p>"},{"location":"coding/kotlin/jooq/#vorteile","title":"Vorteile","text":"<ol> <li> <p>Typesicherheit: Jede Abfrage wird kompiliert, sodass Fehler wie falsche Spaltennamen oder ungueltige Datentypen waehrend der Kompilierung erkannt werden.</p> </li> <li> <p>SQL-Unterstuetzung: Unterstuetzt die meisten SQL-Dialekte und erlaubt SQL nativ zu schreiben.</p> </li> <li> <p>Erzeugung von Code: Generiert Klassen fuer Tabellen, Spalten und anderen Elemente. DAdurch kann das Objekt direkt verwendet werden, anstatt strings fuer die SQL-Abfragen zu schreiben.</p> </li> <li> <p>Flexibilitaet:  Man muss sich sich nicht an ORM-Konventionen wie Entities und LazyLoading halten.</p> </li> <li> <p>Leichte Integration: Funktioniert mit bestehenden JDBC-Treibern und mit anderen Frameworks wie SpringBoot.</p> </li> </ol>"},{"location":"coding/kotlin/jooq/#nachteile","title":"Nachteile","text":"<ol> <li> <p>SQL-Lastig: Erfordert SQL-Kenntnisse und direkte SQL-Integration in den Code.</p> </li> <li> <p>Kein automatisches Caching:  Benoetigt man ein Caching muss dieses selbst implementiert oder durch ein separates Framework wie Redis eingefuehrt werden. Im Vergleich: Hibernate bietet ein integriertes First- und Second-Level-Caching an.</p> </li> <li> <p>Codegenerierung: Die benoetigten Klassen muessen kompiliert werden und ist damit nicht im NoSQL-Bereich geeginet oder wenn dynamische Datenbankstrukturen notwendig sind.</p> </li> <li> <p>Potenzielle SQL-Injektions: Auch wenn qOOQ typsicher ist, kann man durch die Implementierung roher SQL-Abfragen das Risiko fuer SQL-Injektions erhoehen - hier ist vorsicht bei der Entwicklung geboten.</p> </li> </ol>"},{"location":"coding/kotlin/jooq/#wann-setzte-ich-jooq-ein","title":"Wann setzte ich jOOQ ein?","text":"<p>Es ist ideal wenn:</p> <ul> <li>SQL direkt und typesicher eingesetet werden soll</li> <li>man komplexe und massgeschneiderte Abfragen benoetigt</li> <li>man die kontrolle ueber die Datenbank-Interaktionen behalten moechte</li> </ul> <p>Es ist nicht ideal wenn:</p> <ul> <li>man nur einfache CRUD-Operationen benoetigt</li> <li>Caching oder ORM-Funktionen wie LazyLoading benoetigt werden</li> <li>eine dynamische DAtenbankstruktur vorliegt</li> </ul>"},{"location":"coding/kotlin/jooq/#wie-funktioniert-jooq","title":"Wie funktioniert jOOQ?","text":"<p>jOOQ generiert die Klassen (z.B. fuer Tabellen, Views, Sequenzen) basierend auf der Datenbankstruktur. Dieser Prozess funktioniert wie folgt:</p> <ol> <li>Verbindung zur Datenbank</li> <li>Analyse der Struktur (Tabellen, Spalten, Typen, Constraints)</li> <li>Codegenerierung basierend auf den Metadaten, darunter Tabellen- und Record-Klassen</li> <li>Speicherung in <code>target/generated-sources/jooq</code></li> </ol>"},{"location":"coding/kotlin/jooq/#was-wird-fuer-die-generierung-benoetigt","title":"Was wird fuer die Generierung benoetigt?","text":"<ol> <li>Maven-Plugin</li> <li>Datenbankverbindung - Details wie JDBC-Url, Benutzername, Passwort</li> <li>Generator-Konfiguration - Welche Datenbank wird verwendet, Ausschluss von Tabellen und Schemas, Zielort</li> </ol>"},{"location":"coding/kotlin/jooq/#beispiel","title":"Beispiel:","text":"<p>Folgende Tabelle wurde erzeugt:</p> <pre><code>CREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    email VARCHAR(100) NOT NULL\n);\n</code></pre>"},{"location":"coding/kotlin/jooq/#jooq-generiert","title":"jOOQ generiert","text":"<p>Tabellenklasse:Users <pre><code>package com.example.jooqdemo.generated.tables\n\nimport org.jooq.impl.TableImpl\nimport org.jooq.TableField\nimport org.jooq.impl.DSL\nimport com.example.jooqdemo.generated.tables.records.UserRecord\n\nobject Users : TableImpl&lt;UserRecord&gt;(\"users\") {\n    val ID: TableField&lt;UserRecord, Long&gt; = createField(\"id\", DSL.bigint(), this)\n    val NAME: TableField&lt;UserRecord, String&gt; = createField(\"name\", DSL.varchar(100), this)\n    val EMAIL: TableField&lt;UserRecord, String&gt; = createField(\"email\", DSL.varchar(100), this)\n}\n</code></pre></p> <p>POJO:User <pre><code>package com.example.jooqdemo.generated.tables.pojos\n\ndata class User(\n    var id: Long? = null,\n    var name: String? = null,\n    var email: String? = null\n)\n</code></pre></p> <p>Record:UserRecord <pre><code>package com.example.jooqdemo.generated.tables.records\n\nimport org.jooq.impl.UpdatableRecordImpl\n\nclass UserRecord : UpdatableRecordImpl&lt;UserRecord&gt;(Users) {\n    var id: Long? = null\n    var name: String? = null\n    var email: String? = null\n}\n</code></pre></p>"},{"location":"coding/kotlin/jooq/#nutzung","title":"Nutzung","text":"<pre><code>package com.example.jooqdemo.config\n\nimport org.jooq.DSLContext\nimport org.jooq.impl.DSL\nimport org.springframework.context.annotation.Bean\nimport org.springframework.context.annotation.Configuration\nimport javax.sql.DataSource\n\n@Configuration\nclass JooqConfig(private val dataSource: DataSource) {\n\n    @Bean\n    fun dslContext(): DSLContext {\n        return DSL.using(dataSource.connection)\n    }\n}\n</code></pre> <pre><code>package com.example.jooqdemo.repository\n\nimport com.example.jooqdemo.generated.tables.Users\nimport com.example.jooqdemo.generated.tables.Orders\nimport com.example.jooqdemo.generated.tables.pojos.User\nimport org.jooq.DSLContext\nimport org.springframework.stereotype.Repository\n\n@Repository\nclass UserRepository(private val dsl: DSLContext) {\n\n    // INSERT: Benutzer hinzuf\u00fcgen\n    fun addUser(name: String, email: String): Int {\n        return dsl.insertInto(Users.USERS)\n            .columns(Users.USERS.NAME, Users.USERS.EMAIL)\n            .values(name, email)\n            .execute()\n    }\n\n    // UPDATE: Benutzer-E-Mail aktualisieren\n    fun updateUserEmail(userId: Long, newEmail: String): Int {\n        return dsl.update(Users.USERS)\n            .set(Users.USERS.EMAIL, newEmail)\n            .where(Users.USERS.ID.eq(userId))\n            .execute()\n    }\n\n    // DELETE: Benutzer l\u00f6schen\n    fun deleteUserById(userId: Long): Int {\n        return dsl.deleteFrom(Users.USERS)\n            .where(Users.USERS.ID.eq(userId))\n            .execute()\n    }\n\n    // JOIN: Benutzer mit Bestellungen abrufen\n    fun findUsersWithOrders(): List&lt;Pair&lt;User, Int&gt;&gt; {\n        return dsl.select(Users.USERS.asterisk(), Orders.ORDERS.ID.count())\n            .from(Users.USERS)\n            .join(Orders.ORDERS).on(Users.USERS.ID.eq(Orders.ORDERS.USER_ID))\n            .groupBy(Users.USERS.ID)\n            .fetch { record -&gt; \n                val user = record.into(User::class.java)\n                val orderCount = record.get(Orders.ORDERS.ID.count())\n                user to orderCount\n            }\n    }\n\n    // Raw SQL: Manuelle SQL-Abfrage\n    fun rawQuery(): List&lt;User&gt; {\n        return dsl.fetch(\"SELECT * FROM users WHERE email LIKE ?\", \"%example.com%\")\n            .into(User::class.java) // Mappe das Ergebnis auf das `User`-POJO\n    }\n}\n</code></pre> <pre><code>package com.example.jooqdemo.service\n\nimport com.example.jooqdemo.repository.UserRepository\nimport com.example.jooqdemo.generated.tables.pojos.User\nimport org.springframework.stereotype.Service\n\n@Service\nclass UserService(private val userRepository: UserRepository) {\n\n    fun addUser(name: String, email: String): Int {\n        return userRepository.addUser(name, email)\n    }\n\n    fun updateUserEmail(userId: Long, newEmail: String): Int {\n        return userRepository.updateUserEmail(userId, newEmail)\n    }\n\n    fun deleteUserById(userId: Long): Int {\n        return userRepository.deleteUserById(userId)\n    }\n\n    fun findUsersWithOrders(): List&lt;Pair&lt;User, Int&gt;&gt; {\n        return userRepository.findUsersWithOrders()\n    }\n\n    fun rawQuery(): List&lt;User&gt; {\n        return userRepository.rawQuery()\n    }\n}\n</code></pre>"},{"location":"coding/kotlin/maven/","title":"Maven","text":"<p>Maven ist ein Tool das zur Paketverwaltung in Java-Projekten eingesetzt werden kann um diese zu organisieren und auch um Automatisierungen einzubauen. </p>"},{"location":"coding/kotlin/maven/#project-object-model-pom","title":"Project Object Model - POM","text":"<p>Die Konfiguration eines Projektes, welches Maven einsetzt, wird mittels eines Projekt Object Models (POM) realisiert. Dieses PIM wird durch die pom.xml im Projekt-Root abgebildet. </p> <p>Diese Datei beschreibt...</p> <ul> <li>das Projekt</li> <li>Abhaengigkeiten zu Paketen</li> <li>Konfigurationen von Plugins</li> <li>Relationen zu Modulen anderer Projekte</li> </ul> <pre><code>&lt;project&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;example&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;com.example&lt;/name&gt;\n    &lt;url&gt;http://maven.apache.org&lt;/url&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n           //...\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n            //...\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#dependencies","title":"Dependencies","text":"<p>Abhaengigkeiten werden in der POM wie folgt definiert:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n    &lt;version&gt;5.3.16&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#properties","title":"Properties","text":"<p>Um eine Verbesserung der Wartbarkeit innerhalb der POM zu gewaehrleisten koennen zB Versionsnummern in properties  ueberfuehrt werden um diese wieder zu verwenden. So muss man nur einmal die Versionsnummer anpassen:</p> <pre><code>&lt;properties&gt;\n    &lt;spring.version&gt;5.3.16&lt;/spring.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n        &lt;version&gt;${spring.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;${spring.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"coding/kotlin/maven/#lifecycle","title":"Lifecycle","text":"<ul> <li>validate - Ueberprueft die Korrektheit des Projektes</li> <li>compile - Compiliert den SourceCode in ein Artefakt</li> <li>test - Ausfuehrung von Unittests</li> <li>package - Kompilierung des Codes</li> <li>integration-test - Tests, die auf den Paketen aufbauen</li> <li>verify - Validiert die Pakete</li> <li>install - Installiert die Pakete in das lokale Maven Repository</li> <li>deploy - Deployed die Pakete auf einen Remote Server oder in ein Repository</li> </ul>"},{"location":"coding/kotlin/maven/#wichtige-befehle","title":"Wichtige Befehle","text":"<p>Ein ausgefuehrter Befehl fuehrt auch immer die vorhergehenden notwendigen Punkte des Lifecycle aus.</p> Befehl Beschreibung mvn clean Cleans the project by deleting the target directory mvn compiler:compile Compiles the source classes mvn package Build the project and create the JAR/WAR files mvn install Build the project and install package files to local repository mvn deploy Deploy the build artifact to the remote repository mvn validate Validate the project is correct als everything is available mvn dependency:tree Generates the dependency tree of the project mvn dependency:analyze Analyze the project and identify the unused delcared dependencies mvn test Tests the source code mvn verify Run any checks on results of integration tests mvn compile compile the source code of the project"},{"location":"coding/macOs/environment/","title":"Environment","text":"<p>Diese Seite soll mir dabei helfen, Anforderungen an mein Macbook zu definieren und als Art Anleitung zum neuaufsetzen eines Macbooks.</p>"},{"location":"coding/macOs/environment/#anforderungen-an-mein-macbook","title":"Anforderungen an mein Macbook","text":"<ul> <li>Softwareentwicklung mit folgenden Frameworks, Technologien und Software<ul> <li>Kotlin</li> <li>Java</li> <li>Docker</li> <li>Gradle</li> <li>Python</li> <li>Git</li> <li>IntelliJ</li> </ul> </li> </ul>"},{"location":"coding/macOs/environment/#alfred","title":"Alfred","text":"<p>Alfred bietet eine effizientere Erweiterung fuer MacOs als die Spotlight-Suche vom Os selbst. Daher sollte die AlfredApp installiert werden: https://www.alfredapp.com/</p>"},{"location":"coding/macOs/environment/#brew","title":"Brew","text":"<p>Brew ist relativ einfach installiert. Man oeffnet das Terminal und gibt folgende Zeile ein</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Nachfolgend sind die weiteren Installationen relativ schnell erledigt.</p>"},{"location":"coding/macOs/environment/#softwareinstallationen-mit-brew","title":"Softwareinstallationen mit Brew","text":"<pre><code># GIT\nbrew install git\n\n# Docker\nbrew install docker\n</code></pre>"},{"location":"coding/macOs/environment/#terminal","title":"Terminal","text":"<p>Als Terminal faellt die Wahl auf iTerm2 mit einigen Modifikationen.</p> <pre><code>brew cask install iterm2\n</code></pre>"},{"location":"coding/macOs/environment/#zsh-oh-my-zsh","title":"zsh &amp; \"oh-my-zsh\"","text":"<p>Um zsh zu installieren nutzten wir im Terminal: </p> <pre><code>brew install zsh\n</code></pre> <p>Fuer eine Installation von oh-my-zsh nutzen wir nachfolgenden Befehl, wodurch das Standardterminal  anschliessend automatisch durch zsh ersetzt wird. </p> <pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"coding/macOs/environment/#install-fuck","title":"Install 'Fuck'","text":"<p>Eins der besten Plugins fuer Faule und Menschen die gerne Tippfehler in der Konsole begehen.ds</p> <pre><code>brew install thefuck\n</code></pre>"},{"location":"coding/macOs/environment/#wichtige-anpassungen","title":"Wichtige Anpassungen","text":"<p>Die zsh_fallout.json zu den Profilen hinzufuegen.</p>"},{"location":"coding/macOs/environment/#theme","title":"Theme","text":"<p>Zuerst muessen wir das Theme konfigurieren. Hierzu benoetigen wie einige Fonts etc.</p> <pre><code>sudo apt install fonts-powerline\n\ngit clone https://github.com/abertsch/Menlo-for-Powerline.git\ncd Menlo-for-Powerline\ncp \"Menlo for Powerline.ttf\" ~/.fonts\n</code></pre> <pre><code>vi ~/.zshrc\n\n# Set name of the theme to load --- if set to \"random\", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME=\"agnoster\"\n</code></pre>"},{"location":"coding/macOs/environment/#plugins","title":"Plugins","text":"<p>Um externe Plugins zu installieren kann dieser Befehl genutzt werden <pre><code>git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions\n</code></pre></p> <pre><code>vi ~/.zshrc\n\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(\n  git\n  github\n  brew\n  docker\n  npm\n  macos\n  bgnotify\n  zsh-syntax-highlighting\n  zsh-autosuggestions\n  web-search\n)\n</code></pre>"},{"location":"coding/macOs/environment/#alias-parameter","title":"Alias Parameter","text":"<pre><code>vi ~/.zshrc\n\n# Example aliases\n# alias zshconfig=\"mate ~/.zshrc\"\n# alias ohmyzsh=\"mate ~/.oh-my-zsh\"\n\nalias zshconfig=\"nano ~/.zshrc\"\nalias ohmyzsh=\"nano ~/.oh-my-zsh\"\nalias gpf='git push -f'\n\n# Docker alias\nalias dkps=\"docker ps\"\nalias dkst=\"docker stats\"\nalias dkpsa=\"docker ps -a\"\nalias dkimgs=\"docker images\"\nalias dkcpup=\"docker-compose up -d\"\nalias dkcpdown=\"docker-compose down\"\nalias dkcpstart=\"docker-compose start\"\nalias dkcpstop=\"docker-compose stop\"\n\n# Kubectl alias\nalias kdev='kubectl -n dev'\nalias kpg='kubectl -n playground'\nalias ktest='kubectl -n test'\nalias kprod='kubectl -n prod'\nalias kpreprod='kubectl -n preprod'\nalias vpnstart='~/Scripts/vpn-start.sh'\nalias vpn-start='~/Scripts/vpn-start.sh'\n\neval $(thefuck --alias)\n</code></pre>"},{"location":"coding/macOs/environment/#macbook-shortcuts","title":"Macbook shortcuts","text":"<p>TBD</p>"}]}